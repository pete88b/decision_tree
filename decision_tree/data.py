# AUTOGENERATED! DO NOT EDIT! File to edit: 10_data.ipynb (unless otherwise specified).

__all__ = ['add_dateparts', 'fix_missing', 'numericalize', 'proc_df', 'DataWrapper']

# Cell
from .imports import *
from .core import *

# Cell
def add_dateparts(df, col):
    """converts a column of df from a datetime64 to many columns containing
    the information from the date - inplace."""
    targ_pre = re.sub('[Dd]ate$', '', col.name)
    attrs = ['Year', 'Month', 'Week', 'Day', 'Dayofweek', 'Dayofyear',
             'Is_month_end', 'Is_month_start', 'Is_quarter_end', 'Is_quarter_start',
             'Is_year_end', 'Is_year_start']
    for attr in attrs: df[targ_pre + attr] = getattr(col.dt, attr.lower())
    df[targ_pre + 'Elapsed'] = col.astype(np.int64) // 10 ** 9
    df.drop(col.name, axis=1, inplace=True)

# Cell
def fix_missing(df, col, na_dict):
    """ Fill missing data in a column of df with the median, and add a {name}_na column
    which specifies if the data was missing."""
    name = col.name
    if pd.isnull(col).sum() or (name in na_dict):
        df[name + '_na'] = pd.isnull(col)
        na_dict[name] = na_dict[name] if name in na_dict else col.median()
        df[name] = col.fillna(na_dict[name])

# Cell
def numericalize(df, col):
    """Changes col from date/string categorical type to its integer codes + 1."""
    df[col.name] = pd.Categorical(col).codes+1

# Cell
def proc_df(df, y_name, na_dict=None):
    """y_name name of the column that holds the dependent variable """
    df = df.infer_objects() # make a copy and convert cols of object type to more specific types
    if not is_numeric_dtype(df[y_name]): df[y_name] = pd.Categorical(df[y_name]).codes
    y = df[y_name]
    df.drop([y_name], axis=1, inplace=True)
    na_dict = {} if na_dict is None else na_dict.copy()
    for _, col in df.items():
        if pd.isnull(col).all() and col.name not in na_dict:
            print(f'WARNING: all values for {col.name} are null. Column will be dropped')
            df.drop(col.name, axis=1, inplace=True)
        elif is_numeric_dtype(col): fix_missing(df, col, na_dict)
        elif np.issubdtype(col.dtype, np.datetime64): add_dateparts(df, col)
        else: numericalize(df, col)
    return df, y, na_dict

# Cell
class DataWrapper():
    "Wraps the data that could be used for training trees or making predictions"

    @classmethod
    def from_pandas(cls, x, y):
        "x:dataframe, y:series" # TODO:  support more input types
        return DataWrapper(x.to_numpy(copy=True), y.to_numpy(copy=True), x.columns.to_numpy(copy=True), y.name)

    @classmethod
    def from_data_wrapper(cls, data, sample_idxs):
        return DataWrapper(data.x[sample_idxs], data.y[sample_idxs], data.x_names, data.y_name)

    def __init__(self, x, y, x_names, y_name=None):
        self.x, self.y, self.x_names, self.y_name = x, y, x_names, y_name if y_name else 'y'
        self.x_rows, self.x_cols = self.x.shape
        self.all_x_col_idxs = np.arange(self.x_cols)
        self.all_x_row_idxs = np.arange(self.x_rows)
        # TODO: check that x and y can work together - same length etc

    def get_sample(self, sample_idxs, col_idx=None):
        "sample_idxs: int for single row, array of ints for multiple rows"
        if col_idx is None: return self.x[sample_idxs], self.y[sample_idxs]
        return self.x[sample_idxs, col_idx], self.y[sample_idxs]

    def head(self, n_rows):
        return DataWrapper.from_data_wrapper(self, slice(n_rows))

    def tail(self, n_rows):
        # TODO: raise error if n_rows > x_rows
        return DataWrapper.from_data_wrapper(self, slice(self.x_rows-n_rows, self.x_rows))

    def __repr__(self):
        return f'DataWrapper(x:{self.x_names} y:{self.y_name}, len:{len(self.x)})'